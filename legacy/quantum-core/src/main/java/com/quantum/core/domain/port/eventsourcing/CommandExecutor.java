package com.quantum.core.domain.port.eventsourcing;

import com.quantum.core.application.command.StreamCommand;
import com.quantum.core.application.event.DomainEvent;
import com.quantum.core.application.state.AggregateState;
import java.util.List;

/**
 * Interface for executing commands and generating events Implements the Command pattern for event
 * sourcing
 *
 * @param <T> the aggregate state type this executor operates on
 */
public interface CommandExecutor<T extends AggregateState> {

    /**
     * Execute a command against the current aggregate state
     *
     * @param command the command to execute
     * @param currentState the current state of the aggregate
     * @return list of events generated by the command execution
     */
    List<DomainEvent> execute(StreamCommand command, T currentState);

    /**
     * Get the initial state for a new aggregate
     *
     * @param streamId the stream identifier
     * @return the initial state for the aggregate
     */
    T getInitialState(String streamId);

    /**
     * Apply events to reconstruct aggregate state This method is used for state rehydration from
     * event streams
     *
     * @param currentState the current state (or initial state)
     * @param events the events to apply
     * @return the new state after applying all events
     */
    T applyEvents(T currentState, List<DomainEvent> events);

    /**
     * Apply a single event to the current state
     *
     * @param currentState the current state
     * @param event the event to apply
     * @return the new state after applying the event
     */
    T applyEvent(T currentState, DomainEvent event);

    /**
     * Check if this executor can handle the given command type
     *
     * @param commandType the command type to check
     * @return true if this executor can handle the command type
     */
    boolean canHandle(String commandType);

    /**
     * Check if this executor can handle the given command
     *
     * @param command the command to check
     * @return true if this executor can handle the command
     */
    default boolean canHandle(StreamCommand command) {
        return canHandle(command.getClass().getSimpleName());
    }

    /**
     * Get the aggregate type this executor operates on
     *
     * @return the aggregate type name
     */
    default String getAggregateType() {
        return "Unknown";
    }

    /**
     * Validate a command before execution
     *
     * @param command the command to validate
     * @param currentState the current aggregate state
     * @throws CommandValidationException if the command is invalid
     */
    default void validate(StreamCommand command, T currentState) throws CommandValidationException {
        // Default implementation - no validation
    }

    /** Exception thrown when command validation fails */
    class CommandValidationException extends RuntimeException {
        public CommandValidationException(String message) {
            super(message);
        }

        public CommandValidationException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
