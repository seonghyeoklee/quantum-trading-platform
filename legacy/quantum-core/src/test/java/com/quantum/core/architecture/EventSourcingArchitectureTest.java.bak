package com.quantum.core.architecture;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * Event Sourcing 아키텍처 규칙 검증 테스트
 * 
 * Event Sourcing 패턴의 핵심 원칙들을 ArchUnit으로 강제한다:
 * 1. Event의 불변성
 * 2. Command와 Event의 명확한 분리
 * 3. Event Store의 올바른 구현
 * 4. State Rehydration 패턴
 * 5. Message Bus와 Event Handler의 올바른 구조
 */
@DisplayName("⚡ Event Sourcing Architecture Rules")
class EventSourcingArchitectureTest {

    private static final String BASE_PACKAGE = "com.quantum.core";
    private static final JavaClasses classes = new ClassFileImporter()
            .importPackages(BASE_PACKAGE);

    @Test
    @DisplayName("Event는 불변이어야 하고 과거형 명명을 사용해야 한다")
    void events_should_be_immutable_and_use_past_tense() {
        classes()
                .that().haveSimpleNameEndingWith("Event")
                .should().haveOnlyFinalFields()
                .andShould().haveSimpleNameMatching(".*ed$|.*Event$")
                .because("Event는 발생한 사실을 나타내므로 불변이고 과거형이어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Command는 의도를 나타내는 명령형 명명을 사용해야 한다")
    void commands_should_use_imperative_naming() {
        classes()
                .that().haveSimpleNameEndingWith("Command")
                .should().haveSimpleNameMatching("(Create|Update|Delete|Execute|Process|Send).*Command$")
                .because("Command는 수행할 작업의 의도를 명확히 표현해야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Event Store는 포트 인터페이스로 정의되어야 한다")
    void event_store_should_be_port_interface() {
        classes()
                .that().haveSimpleName("EventStore")
                .should().beInterfaces()
                .andShould().resideInAPackage("..domain.port.eventsourcing..")
                .because("Event Store는 도메인 포트로 정의되어 구현체와 분리되어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Event Store 구현체는 Infrastructure 계층에 있어야 한다")
    void event_store_implementations_should_be_in_infrastructure() {
        classes()
                .that().haveSimpleNameContaining("EventStore")
                .and().areNotInterfaces()
                .should().resideInAPackage("..infrastructure.eventsourcing..")
                .because("Event Store 구현체는 인프라스트럭처의 기술적 세부사항임")
                .check(classes);
    }

    @Test
    @DisplayName("CommandExecutor는 포트 인터페이스여야 한다")
    void command_executor_should_be_port_interface() {
        classes()
                .that().haveSimpleNameEndingWith("CommandExecutor")
                .should().beInterfaces()
                .andShould().resideInAPackage("..domain.port.eventsourcing..")
                .because("CommandExecutor는 도메인 포트로 정의되어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("EventHandler는 포트 인터페이스여야 한다")
    void event_handler_should_be_port_interface() {
        classes()
                .that().haveSimpleNameEndingWith("EventHandler")
                .should().beInterfaces()
                .andShould().resideInAPackage("..domain.port.eventsourcing..")
                .because("EventHandler는 도메인 포트로 정의되어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("State는 Event로부터 복원 가능해야 한다")
    void states_should_be_rehydratable_from_events() {
        classes()
                .that().haveSimpleNameEndingWith("State")
                .should().resideInAPackage("..application.state..")
                .because("State는 Event로부터 복원되는 집계 상태를 나타냄")
                .check(classes);
    }

    @Test
    @DisplayName("StateRehydrator는 Event Sourcing 포트에 정의되어야 한다")
    void state_rehydrator_should_be_in_eventsourcing_port() {
        classes()
                .that().haveSimpleNameContaining("StateRehydrator")
                .should().resideInAPackage("..domain.port.eventsourcing..")
                .or().resideInAPackage("..infrastructure.eventsourcing..")
                .because("StateRehydrator는 Event Sourcing의 핵심 컴포넌트임")
                .check(classes);
    }

    @Test
    @DisplayName("Message Bus는 포트 인터페이스로 정의되어야 한다")
    void message_bus_should_be_port_interface() {
        classes()
                .that().haveSimpleName("MessageBus")
                .should().beInterfaces()
                .andShould().resideInAPackage("..domain.port.messaging..")
                .because("Message Bus는 도메인 포트로 정의되어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Event Serializer는 기술적 세부사항으로 Infrastructure에 있어야 한다")
    void event_serializer_should_be_in_infrastructure() {
        classes()
                .that().haveSimpleNameContaining("EventSerializer")
                .should().resideInAPackage("..infrastructure.eventsourcing..")
                .or().resideInAPackage("..domain.port.eventsourcing..")
                .because("Event Serializer는 기술적 세부사항임")
                .check(classes);
    }

    @Test
    @DisplayName("Headspring(Event Sourcing Engine)은 포트 인터페이스여야 한다")
    void headspring_should_be_port_interface() {
        classes()
                .that().haveSimpleName("Headspring")
                .should().beInterfaces()
                .andShould().resideInAPackage("..domain.port.eventsourcing..")
                .because("Headspring은 Event Sourcing의 핵심 엔진 인터페이스임")
                .check(classes);
    }

    @Test
    @DisplayName("Event는 타임스탬프를 가져야 한다")
    void events_should_have_timestamp() {
        classes()
                .that().haveSimpleNameEndingWith("Event")
                .and().resideInAPackage("..application.event..")
                .should().containNumberOfElements(0)
                .orShould().haveFieldThat(field -> 
                    field.getName().contains("timestamp") || 
                    field.getName().contains("occurredAt") ||
                    field.getName().contains("createdAt")
                )
                .because("Event는 발생 시간을 기록해야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Command와 Event는 Aggregate ID를 가져야 한다")
    void commands_and_events_should_have_aggregate_id() {
        classes()
                .that().haveSimpleNameEndingWith("Command")
                .or().haveSimpleNameEndingWith("Event")
                .should().containNumberOfElements(0)
                .orShould().haveFieldThat(field -> 
                    field.getName().contains("Id") || 
                    field.getName().contains("aggregateId") ||
                    field.getName().contains("entityId")
                )
                .because("Command와 Event는 대상 집계를 식별할 수 있어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Event와 Command는 직렬화 가능해야 한다")
    void events_and_commands_should_be_serializable() {
        classes()
                .that().haveSimpleNameEndingWith("Event")
                .or().haveSimpleNameEndingWith("Command")
                .should().beAnnotatedWith("com.fasterxml.jackson.annotation.JsonTypeInfo")
                .orShould().haveMethodThat(method -> method.getName().contains("serialize"))
                .orShould().haveOnlyFinalFields() // record나 불변 객체라면 기본적으로 직렬화 가능
                .because("Event와 Command는 저장과 전송을 위해 직렬화 가능해야 함")
                .check(classes);
    }

    @Test
    @DisplayName("AbstractDomainEvent는 공통 Event 속성을 정의해야 한다")
    void abstract_domain_event_should_define_common_properties() {
        classes()
                .that().haveSimpleName("AbstractDomainEvent")
                .should().beAbstract()
                .andShould().resideInAPackage("..application.event..")
                .because("AbstractDomainEvent는 모든 이벤트의 공통 속성을 정의해야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Event Sourcing 구성은 Configuration에 정의되어야 한다")
    void event_sourcing_configuration_should_be_properly_located() {
        classes()
                .that().haveSimpleNameContaining("EventSourcing")
                .and().haveSimpleNameEndingWith("Configuration")
                .should().resideInAPackage("..infrastructure.config..")
                .because("Event Sourcing 설정은 인프라스트럭처 설정임")
                .check(classes);
    }
}