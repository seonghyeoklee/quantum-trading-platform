package com.quantum.core.architecture;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.library.Architectures;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * Hexagonal Architecture (Ports and Adapters) 검증 테스트
 * 
 * 헥사고날 아키텍처의 핵심 원칙들을 ArchUnit으로 강제한다:
 * 1. Domain 계층은 Infrastructure에 의존하지 않음
 * 2. Port 인터페이스는 Adapter 구현체에 의존하지 않음
 * 3. Application 계층은 Domain만 의존
 * 4. Infrastructure는 Domain/Application에 의존할 수 있지만 역방향은 금지
 */
@DisplayName("🏗️ Hexagonal Architecture Rules")
class HexagonalArchitectureTest {

    private static final String BASE_PACKAGE = "com.quantum.core";
    private static final JavaClasses classes = new ClassFileImporter()
            .importPackages(BASE_PACKAGE);

    @Test
    @DisplayName("레이어드 아키텍처 구조가 올바르게 정의되어야 한다")
    void layered_architecture_should_be_respected() {
        Architectures.layeredArchitecture()
                .consideringOnlyDependenciesInLayers()
                .layer("Domain").definedBy("..domain..")
                .layer("Application").definedBy("..application..")
                .layer("Infrastructure").definedBy("..infrastructure..")
                
                .whereLayer("Domain").mayNotAccessAnyLayer()
                .whereLayer("Application").mayOnlyAccessLayers("Domain")
                .whereLayer("Infrastructure").mayAccessLayers("Domain", "Application")
                
                .check(classes);
    }

    @Test
    @DisplayName("도메인 계층은 인프라스트럭처 계층에 의존하지 않아야 한다")
    void domain_should_not_depend_on_infrastructure() {
        noClasses()
                .that().resideInAPackage("..domain..")
                .should().dependOnClassesThat().resideInAPackage("..infrastructure..")
                .because("도메인 계층은 비즈니스 로직만 포함하고 기술적 세부사항에 의존하지 않아야 함")
                .check(classes);
    }

    @Test
    @DisplayName("포트 인터페이스는 어댑터 구현체에 의존하지 않아야 한다")
    void ports_should_not_depend_on_adapters() {
        noClasses()
                .that().resideInAPackage("..domain.port..")
                .should().dependOnClassesThat().resideInAPackage("..infrastructure..")
                .because("포트는 인터페이스로서 어댑터 구현체에 의존하지 않아야 함")
                .check(classes);
    }

    @Test
    @DisplayName("애플리케이션 계층은 도메인 계층만 의존해야 한다")
    void application_should_only_depend_on_domain() {
        classes()
                .that().resideInAPackage("..application..")
                .should().onlyDependOnClassesThat()
                .resideInAnyPackage(
                        "..domain..",
                        "java..",
                        "org.springframework..",
                        "jakarta..",
                        "com.fasterxml.jackson.."
                )
                .because("애플리케이션 계층은 도메인 계층과 표준 라이브러리만 사용해야 함")
                .check(classes);
    }

    @Test
    @DisplayName("도메인 모델은 순수한 비즈니스 로직만 포함해야 한다")
    void domain_models_should_be_pure() {
        classes()
                .that().resideInAPackage("..domain.model..")
                .should().onlyDependOnClassesThat()
                .resideInAnyPackage(
                        "..domain..",
                        "java..",
                        "jakarta.persistence..",  // JPA 어노테이션 허용
                        "jakarta.validation..",   // Validation 어노테이션 허용
                        "lombok..",               // Lombok 허용
                        "com.fasterxml.jackson.." // JSON 어노테이션 허용
                )
                .because("도메인 모델은 비즈니스 로직과 필수 기술 어노테이션만 사용해야 함")
                .check(classes);
    }

    @Test
    @DisplayName("포트 인터페이스는 인터페이스여야 한다")
    void ports_should_be_interfaces() {
        classes()
                .that().resideInAPackage("..domain.port..")
                .and().areTopLevelClasses()
                .should().beInterfaces()
                .because("포트는 인터페이스로 정의되어 구현체와 분리되어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Repository 구현체는 Infrastructure 계층에 있어야 한다")
    void repository_implementations_should_be_in_infrastructure() {
        classes()
                .that().haveSimpleNameEndingWith("RepositoryImpl")
                .or().haveSimpleNameEndingWith("RepositoryAdapter")
                .should().resideInAPackage("..infrastructure..")
                .because("Repository 구현체는 인프라스트럭처 계층에서 기술적 세부사항을 처리해야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Service 인터페이스는 Domain Port에 정의되어야 한다")
    void service_interfaces_should_be_in_domain_ports() {
        classes()
                .that().areInterfaces()
                .and().haveSimpleNameEndingWith("Service")
                .should().resideInAPackage("..domain.port.service..")
                .because("서비스 인터페이스는 도메인 포트로 정의되어야 함")
                .check(classes);
    }

    @Test
    @DisplayName("Command와 Event는 Application 계층에 정의되어야 한다")
    void commands_and_events_should_be_in_application_layer() {
        classes()
                .that().haveSimpleNameEndingWith("Command")
                .or().haveSimpleNameEndingWith("Event")
                .should().resideInAPackage("..application..")
                .because("Command와 Event는 애플리케이션 계층의 관심사임")
                .check(classes);
    }

    @Test
    @DisplayName("Configuration은 Infrastructure 계층에만 있어야 한다")
    void configurations_should_be_in_infrastructure() {
        classes()
                .that().haveSimpleNameEndingWith("Config")
                .or().haveSimpleNameEndingWith("Configuration")
                .should().resideInAPackage("..infrastructure..")
                .because("기술적 설정은 인프라스트럭처 계층의 책임임")
                .check(classes);
    }
}