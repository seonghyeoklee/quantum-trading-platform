package com.quantum.core.architecture;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.*;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;

/**
 * Domain-Driven Design (DDD) ì›ì¹™ ê²€ì¦ í…ŒìŠ¤íŠ¸
 * 
 * DDDì˜ í•µì‹¬ ì›ì¹™ë“¤ì„ ArchUnitìœ¼ë¡œ ê°•ì œí•œë‹¤:
 * 1. Entityì™€ Value Objectì˜ ì˜¬ë°”ë¥¸ ì„¤ê³„
 * 2. Repository íŒ¨í„´ì˜ ì˜¬ë°”ë¥¸ êµ¬í˜„
 * 3. Domain Serviceì˜ ìˆœìˆ˜ì„±
 * 4. Aggregate ê²½ê³„ ì¤€ìˆ˜
 * 5. ê¸ˆìœµ ë„ë©”ì¸ íŠ¹í™” ê·œì¹™ (BigDecimal ì‚¬ìš© ë“±)
 */
@DisplayName("ğŸ¯ Domain-Driven Design Rules")
class DomainDrivenDesignTest {

    private static final String BASE_PACKAGE = "com.quantum.core";
    private static final JavaClasses classes = new ClassFileImporter()
            .importPackages(BASE_PACKAGE);

    @Test
    @DisplayName("EntityëŠ” ë„ë©”ì¸ ëª¨ë¸ íŒ¨í‚¤ì§€ì— ìˆì–´ì•¼ í•œë‹¤")
    void entities_should_be_in_domain_model_package() {
        classes()
                .that().areAnnotatedWith("jakarta.persistence.Entity")
                .should().resideInAPackage("..domain.model..")
                .because("EntityëŠ” ë„ë©”ì¸ ëª¨ë¸ì˜ í•µì‹¬ì´ë©° ì ì ˆí•œ íŒ¨í‚¤ì§€ì— ìœ„ì¹˜í•´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("Value ObjectëŠ” ë¶ˆë³€ì´ì–´ì•¼ í•œë‹¤")
    void value_objects_should_be_immutable() {
        classes()
                .that().resideInAPackage("..domain.model.common..")
                .and().areNotEnums()
                .and().areNotInterfaces()
                .should().haveOnlyFinalFields()
                .because("Value ObjectëŠ” ë¶ˆë³€ì„±ì„ ë³´ì¥í•´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("Repository ì¸í„°í˜ì´ìŠ¤ëŠ” domain.port.repository íŒ¨í‚¤ì§€ì— ìˆì–´ì•¼ í•œë‹¤")
    void repository_interfaces_should_be_in_domain_ports() {
        classes()
                .that().haveSimpleNameEndingWith("Repository")
                .and().areInterfaces()
                .should().resideInAPackage("..domain.port.repository..")
                .because("Repository ì¸í„°í˜ì´ìŠ¤ëŠ” ë„ë©”ì¸ í¬íŠ¸ë¡œ ì •ì˜ë˜ì–´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("Repository êµ¬í˜„ì²´ëŠ” infrastructure íŒ¨í‚¤ì§€ì— ìˆì–´ì•¼ í•œë‹¤")
    void repository_implementations_should_be_in_infrastructure() {
        classes()
                .that().haveSimpleNameEndingWith("Repository")
                .and().areNotInterfaces()
                .should().resideInAPackage("..infrastructure..")
                .because("Repository êµ¬í˜„ì²´ëŠ” ì¸í”„ë¼ìŠ¤íŠ¸ëŸ­ì²˜ì˜ ê´€ì‹¬ì‚¬ì„")
                .check(classes);
    }

    @Test
    @DisplayName("Domain ServiceëŠ” ìˆœìˆ˜í•´ì•¼ í•œë‹¤ (ì™¸ë¶€ ì˜ì¡´ì„± ìµœì†Œ)")
    void domain_services_should_be_pure() {
        classes()
                .that().resideInAPackage("..domain.service..")
                .should().onlyDependOnClassesThat()
                .resideInAnyPackage(
                        "..domain..",
                        "java..",
                        "org.springframework.stereotype..",
                        "lombok.."
                )
                .because("Domain ServiceëŠ” ìˆœìˆ˜í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ë§Œ í¬í•¨í•´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("ê¸ˆìœµ ê³„ì‚°ì—ëŠ” BigDecimalì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤")
    void financial_calculations_should_use_bigdecimal() {
        noFields()
                .that().areDeclaredInClassesThat().resideInAPackage("..domain.model..")
                .and().haveRawType(double.class)
                .or().haveRawType(float.class)
                .should().exist()
                .because("ê¸ˆìœµ ê³„ì‚°ì—ì„œëŠ” ì •ë°€ë„ ì†ì‹¤ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ BigDecimalì„ ì‚¬ìš©í•´ì•¼ í•¨");

        // Price ê´€ë ¨ í•„ë“œë“¤ì€ BigDecimalì´ì–´ì•¼ í•¨
        fields()
                .that().areDeclaredInClassesThat().resideInAPackage("..domain.model..")
                .and().haveName("price")
                .or().haveName("amount")
                .or().haveName("value")
                .should().haveRawType(BigDecimal.class)
                .because("ê°€ê²©ê³¼ ê¸ˆì•¡ í•„ë“œëŠ” BigDecimalì´ì–´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("EventëŠ” ë¶ˆë³€ì´ì–´ì•¼ í•œë‹¤")
    void events_should_be_immutable() {
        classes()
                .that().haveSimpleNameEndingWith("Event")
                .and().resideInAPackage("..application.event..")
                .should().haveOnlyFinalFields()
                .because("EventëŠ” ë°œìƒí•œ ì‚¬ì‹¤ì„ ë‚˜íƒ€ë‚´ë¯€ë¡œ ë¶ˆë³€ì´ì–´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("CommandëŠ” ìš”ì²­ ì˜ë„ë¥¼ ëª…í™•íˆ í‘œí˜„í•´ì•¼ í•œë‹¤")
    void commands_should_express_intent_clearly() {
        classes()
                .that().haveSimpleNameEndingWith("Command")
                .should().resideInAPackage("..application.command..")
                .because("CommandëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µì—ì„œ ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ë„ë¥¼ í‘œí˜„í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("StateëŠ” Event Sourcingì˜ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ì•¼ í•œë‹¤")
    void states_should_represent_aggregate_state() {
        classes()
                .that().haveSimpleNameEndingWith("State")
                .should().resideInAPackage("..application.state..")
                .because("StateëŠ” Event Sourcingì—ì„œ ì§‘ê³„ì˜ í˜„ì¬ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ„")
                .check(classes);
    }

    @Test
    @DisplayName("EntityëŠ” ID í•„ë“œë¥¼ ê°€ì ¸ì•¼ í•œë‹¤")
    void entities_should_have_id_field() {
        classes()
                .that().areAnnotatedWith("jakarta.persistence.Entity")
                .should().containNumberOfElements(0)
                .orShould().haveFieldThat(field -> 
                    field.getName().equals("id") || 
                    field.getName().endsWith("Id") ||
                    field.isAnnotatedWith("jakarta.persistence.Id")
                )
                .because("EntityëŠ” ì‹ë³„ìë¥¼ ê°€ì ¸ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("Enumì€ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ì„ ìº¡ìŠí™”í•´ì•¼ í•œë‹¤")
    void enums_should_encapsulate_business_rules() {
        classes()
                .that().areEnums()
                .and().resideInAPackage("..domain.model.common..")
                .should().haveMethodThat(method -> !method.getName().equals("values") && !method.getName().equals("valueOf"))
                .because("Enumì€ ë‹¨ìˆœí•œ ìƒìˆ˜ê°€ ì•„ë‹Œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ í¬í•¨í•´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("Builder íŒ¨í„´ì€ ë³µì¡í•œ ê°ì²´ ìƒì„±ì— ì‚¬ìš©ë˜ì–´ì•¼ í•œë‹¤")
    void complex_objects_should_use_builder_pattern() {
        classes()
                .that().haveSimpleNameContaining("Result")
                .or().haveSimpleNameContaining("Request")
                .or().haveSimpleNameContaining("Response")
                .should().haveMethodThat(method -> method.getName().equals("builder"))
                .orShould().haveInnerClassThat(innerClass -> innerClass.getSimpleName().equals("Builder"))
                .because("ë³µì¡í•œ ê°ì²´ëŠ” Builder íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ìƒì„±í•´ì•¼ í•¨")
                .check(classes);
    }

    @Test
    @DisplayName("ë„ë©”ì¸ ì˜ˆì™¸ëŠ” ëª…í™•í•œ ë©”ì‹œì§€ë¥¼ ì œê³µí•´ì•¼ í•œë‹¤")
    void domain_exceptions_should_provide_clear_messages() {
        classes()
                .that().areAssignableTo(RuntimeException.class)
                .and().resideInAPackage("..domain..")
                .should().haveSimpleNameEndingWith("Exception")
                .because("ë„ë©”ì¸ ì˜ˆì™¸ëŠ” ëª…í™•í•œ ë„¤ì´ë°ì„ ê°€ì ¸ì•¼ í•¨")
                .check(classes);
    }
}